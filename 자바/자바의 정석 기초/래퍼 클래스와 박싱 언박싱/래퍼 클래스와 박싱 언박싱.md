# 래퍼 클래스와 박싱 언박싱

자바에서 자료형은 기본 타입(primitive type)과 참조 타입(reference type)으로 구분된다. 기본 타입으로는 char, int, float, double, boolean 등이 있으며 참조 타입으로는 class와 interface 등이 있는데 **자바의 자료형 중 기본 타입에 해당하는 데이터를 객체로 표현하기 위해서 포장해주는 클래스를 래퍼 클래스라고 한다.** 기본 타입의 값을 래퍼 클래스 객체 내부에 두고 포장하기 때문에 포장 객체라고도 불린다. 포장 객체의 값은 직접적으로 변경할 수 없으며 포장 객체의 값을 변경하기 위해서는 새로운 포장 객체를 만들어야 한다.

## 래퍼 클래스의 종류

래퍼 클래스는 기본 타입의 값을 객체로 표현하는 클래스이기 때문에 기본 타입과 일대일로 매핑되는 특징이 있다. 예를들자면 기본타입인 byte 타입의 값을 객체로 표현하기위해서는 Byte 래퍼 클래스를 이용해야만 한다.

- 래퍼 클래스 종류
1. byte -> Byte
2. char -> Character
3. int -> Integer
4. float -> Float
5. double -> Double
6. boolean -> Boolean
7. long -> Long
8. short -> Short


## 박싱(Boxing)과 언박싱(UnBoxing)

지금까지 간단하게 래퍼 클래스에 대해서 알아보았다. 그렇다면 이제 박싱과 언박싱에 대해서 알아보도록 하자. 래퍼 클래스와 박싱, 언박싱을 연관지어서 생각해보자. 아직 우리는 박싱과 언박싱에 대해서 잘 모르지만 이름만으로 래퍼 클래스와 연관지어 개념을 유추해보자.
래퍼 클래스(Wrapper Class)는 기본 타입의 데이터를 Wrapping해서 객체로 표현할 수 있도록 해준다. 그렇다면 여기에서의 Wrapping 이라는 것은 기본 타입의 데이터를 객체로 표현할 수 있도록 값을 래퍼 클래스에 Wrapping 하는 것을 의미하는데 여기서 Wrapping 대신 Boxing이라는 단어를 사용해도 의미상 어색함이 없는 것을 느낄 수 있겠는가 ?
아직 이해가 가지 않는다면 여기서 박싱과 언박싱이 무엇을 의미하는지 듣고난다면 이해가 갈 수 있을 것이다.
기본 타입의 값을 포장 객체로 만드는 과정을 박싱이라고 하며 포장 객체에서 기본 타입의 값을 얻어내는 것을 언박싱이라고 한다.
래퍼 클래스에서 래퍼가 어떤 것을 의미하는지 이해했다면 기본 타입의 값을 래퍼 클래스로 변환하는 것이 박싱, 그 반대의 과정이 언박싱이라는 것을 이름만 보고도 이해할 수 있었을 것이다.
그렇다면 이제 간단하게 임의의 int 타입의 값과 float 값을 박싱, 언박싱하는 예를 보도록 하자.

```java
public class WrapperTest {
    public static void main(String[] args){
        int primitiveIntValue = 3;
        float primitiveFloatValue = 3.14f;

        Integer wrappedIntValue = new Integer(primitiveIntValue);
        Float wrappedFloatValue = new Float(primitiveFloatValue);

        System.out.println("wrappedIntValue : " + wrappedIntValue);
        System.out.println("wrappedFloatValue : " + wrappedFloatValue);

        int returnToPrimitiveInt = wrappedIntValue.intValue();
        float returnToPrimitiveFloat = wrappedFloatValue.floatValue();

        System.out.println("returnToPrimitiveInt : " + returnToPrimitiveInt);
        System.out.println("returnToPrimitiveFloat : " + returnToPrimitiveFloat);
    }
}
```

- 실행결과
```java
wrappedIntValue : 3
wrappedFloatValue : 3.14
returnToPrimitiveInt : 3
returnToPrimitiveFloat : 3.14
```

여기까지는 이해가 가지 않는 부분이 없을 정도로 자연스러운 과정이었다. 그렇다면 아래의 코드를 보았을 때는 어떤 느낌이 드는가 ? 자연스럽다는 느낌이 들지 않는가 ?
자바 11버전을 기준으로 실행하면 아래의 코드는 오류가 발생할 것이다. 하지만 자바 15버전 이후의 버전의 경우에는 오류가 발생하지 않을 것이다. 그 이유를 알기 전에 자바 11으로 아래의 코드를 실행했을 때의 결과와 자바 15버전 이후 버전으로 실행했을 때의 결과를 비교해보자.

```java
public class WrapperTest2 {
    public static void main(String[] args){
        Integer num = 17;
        int n = num;

        System.out.println(num);
        System.out.println(n);
    }
}

```
- 자바 11 버전으로 테스트 코드 실행하기

```java
오류: 기본 클래스 WrapperClassTestClass.WrapperTest2을(를) 로드하는 중 LinkageError가 발생했습니다.
	java.lang.UnsupportedClassVersionError: WrapperClassTestClass/WrapperTest2 has been compiled by a more recent version of the Java Runtime (class file version 62.0), this version of the Java Runtime only recognizes class file versions up to 55.0
```

- 자바 15 버전으로 테스트 코드 실행하기

```java
17
17
```

자바 버전에 따라서 해당 코드의 실행 결과가 달라지는 이유가 무엇일까 ? 
사실 우리가 지금까지 배웠던 것들로만 생각했을 때 기본 타입인 int 타입 변수에 래퍼 클래스인 Interger 객체를 할당할 수 없다. 또 반대로 Integer 객체에 기본 타입인 int 타입 값을 할당할 수 없다.
하지만 자바 15버전 이후부터는 자동 박싱, 자동 언박싱을 지원하기 때문에 자바 11처럼 오류가 발생하지 않고 컴파일러가 자동적으로 박싱, 언박싱 작업을 수행해준다.

대충 눈으로 훑고 넘어갔을때 잘 넘어갈 수 있는 부분이기 때문에 래퍼 클래스에 대한 이해가 충분히 되어 있어야 많은 시간을 간단한 오류를 디버깅하느라고 쓰지 않을 수 있을 것 같다.

이 외에도 래퍼 클래스는 산술 연산자를 사용할 수 없기에 주의해야 한다는 것, 래퍼 클래스에 동등연산자를 사용할 때 주의해야 한다는 것 등 많이 있으므로 주의하자.

래퍼 클래스에 동등연산자를 사용할 때 주의해야 하는 이유에 대해서 궁금하다면 https://shanepark.tistory.com/355 블로그의 글을 참고해보도록 하자.




> 자바 ORM 표준 JPA 프로그래밍을 읽고 작성한 내용입니다.
>

<br>
<br>

# 프록시와 연관관계 관리

이번에는 프록시에 대해서 알아볼 것이다. 프록시란 객체가 데이터베이스에 저장됨으로 인해 연관된 객체를 마음껏
탐색하는 것이 어려워 JPA에서 이 문제 해결하기 위해서 사용하는 기술이다.

프록시를 사용하면 연관된 객체를 처음부터 데이터베이스에서 조회하는 것이 아닌 실제 사용하는 시점에 데이터베이스에서 조회할 수 있다.
하지만 자주 함께 사용하는 객체들은 조인을 사용해 함께 조회하는 것이 효과적인데 **JPA는 즉시 로딩과 지연 로딩이라는 방법으로 둘을 모두 지원한다.**

## 프록시

엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것이 아니다. 그렇기 때문에 한 객체를 조회할 때 당장 필요하지 않은 연관된 객체를
함께 조회하는 것으 효율적이지 않기 때문에 JPA가 이 문제를 해결하려고 엔티티가 실제로 사용될 때까지 데이터베이스 조회를 지연하는
방법을 제공하는데 이것을 **지연 로딩**이라고 한다.

그런데 지연로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을
프록시 객체라고 한다.

### 프록시 기초

JPA애서 식별자로 엔티티 하나를 조회할 때는 EntityManager.find()를 사용한다.
이 메서드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.

```java
Member member = em.find(Member.class, "member1");
```

이렇게 엔티티를 직접 조회하면 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다.
만약 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 EntityManager.getReference() 메서드를 사용하면 된다.

**이 메서드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다. 대신,
데이터베이스 접근을 위임한 프록시 객체를 반환한다.**

프록시 객체는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다. 그렇기 때문에 사용하는 입장에서
이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. 그리고 프록시 객체는 실제 객체에 대한
참조를 보관한다. 그리고 프록시 객체의 메서드를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다.

```java
Member member = em.find(Member.class, "member1");
member.getName();
```

**위처럼 프록시 객체가 실제 객체의 메서드를 호출할 때 데이터베이스를 조회해 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라고 한다.**
그렇다면 이제 프록시의 초기화 과정에 대해서 알아보자.

- 프록시 초기화 과정

1. 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회한다. // member의 name 값 조회
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않다면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라고 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관한다.
5. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환한다.

프록시의 초기화 과정은 위와 같으며 기억해야 할 프록시의 특징은 아래와 같다.

- 프록시의 특징
1. 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
2. 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것이 아니며 프록시 객체가 엔티티 객체의 참조를 보관해 이 참조를 통해 실제 엔티티에 접근한다.
3. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
4. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하므로 준영속 상태의 프록시를 초기화하면 문제가 발생한다.


### 프록시와 식별자

엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.

```java
Team team = em,getReference(Team.class, "team1"); // 식별자 보관
team.getId(); // 초기화되지 않음
``` 

프록시 객체는 식별자 값을 가지고 있으므로 식별자 값을 조회하는 team.getId()를 호출해도 프록시를 초기화하지 않는다.
단 엔티티 접근 방식을 프로퍼티로 설정한 경우에만 초기화하지 않는다.
엔티티 접근 방식을 필드로 설정하면 JPA는 getId() 메서드가 id만 조회하는 메서드인지 다른 필드까지 활용해서 어떤 일을 하는 메서드인지
알지 못하므로 프록시 객체를 초기화한다. **연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면
데이터베이스 접근 횟수를 줄일 수 있다.**


## 즉시 로딩과 지연 로딩

JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 아래의 두가지 방법을 제공한다.

- 즉시로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. 
  - 설정방법 : @ManyToOne(fech = FetchType.EAGER)     

- 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회한다.
  - 설정방법 : @ManyToOne(fech = FetchType.EAGER)



### 즉시 로딩

즉시 로딩(EAGER LOADING)을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.EAGER로 지정한다.

만약 객체 A와 객체 B를 즉시 로딩으로 설정한다면 객체 A를 조회하는 순간 객체 B도 함께 조회한다.
두 객체를 조회할 때는 2번에 걸쳐 조회를 하는 것이 아니라 즉시 로딩을 최적화하기 위해서 가능하면 조인 쿼리를 사용한다.

### 지연 로딩

지연 로딩(LAZY LOADING)을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.LAZY로 지정한다.

즉시 로딩과는 다르게 객체 A와 객체 B를 지연로딩으로 설정한다면 **객체 A를 조회한다고 해서 객체 B까지 조회하지 않는다.
대신 객체 A의 객체 B 멤버 변수에 프록시 객체를 넣어둔다.** 이 프록시 객체는 실제로 사용될 때까지 데이터 로딩을 미루기 때문에
지연로딩이라고 부른다.


### 즉시로딩 지연로딩 정리

처음부터 연관된 모든 엔티티를 영속성 컨텍스트에 올려두는 것은 현실적이지 않고, 필요할 때마다 SQL을 실행해서
연관된 엔티티를 지연 로딩하는 것도 최적화 관점에서 보면 꼭 좋은 것은 아니다. 예를 들어 대부분의 애플리케이션 로직에서 회원과
팀 엔티티를 같이 사용한다면 SQL 조인을 사용해서 회원과 팀 엔티티를 한 번에 조회하는 것이 더 효율적이다.
결국 연관된 엔티티를 즉시 로딩하는 것이 좋은지 아니면 실제 사용할 때까지 지연해서 로딩하는 것이 좋은지는 상황에 따라
다르다.

- 지연 로딩(LAZY) : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩(EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.


## 영속성 전이 : CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence) 기능을 사용하면 된다.
JPA는 CASCADE 옵션으로 영속성 전이를 제공하는데 쉽게 말해서 영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.

만약 부모 1명에 자식 2명을 저장한다면 엔티티를 저장할 때 모든 엔티티는 영속 상태여야 하기 때문에 
부모 엔티티를 영속 상태로 만들고 자식 엔티티도 각각 영속 상태로 만든다. 하지만 이 때 영속성 전이를 사용하면
부모만 영속 상태로 만들면 연관된 자식까지 한 번에 영속 상태로 만들 수 있다.

### 영속성 전이 : 저장

영속성 전이를 활성화하는 CASCADE 옵션을 적용해보자.

```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
    private List<Child> children = new ArrayLisy<Child>();
}
```

부모를 영속화할 때 연관된 자식들도 함께 영속화하기 위해서 cascade = CascadeType.PERSIST 옵션을 설정해줬다.
이 옵션을 적용하면 아래의 예처럼 한번에 부모와 자식을 영속화할 수 있다.

```java
Child child1 = new Child();
Child child2 = new Child();

Parent parent = new Parent();
child1.setParent(parent);
child2.setParent(parent);

parent.getChildren().add(child1);
parent.getChildren().add(child2);

em.persist(parent);
```

위의 부모만 영속화했음에도 불구하도 CascadeType.PERSIST로 설정한 자식 엔티티까지 함께 영속화해서 저장하는 예이다.

### 영속성 전이 : 삭제

영속성 전이는 엔티티를 저장할 때 뿐만 아니라 엔티티를 삭제할 때도 사용할 수 있다.
CascadeType.REMOVE로 설정하고 부모 엔티티만 삭제한다면 부모 엔티티와 연관된 자식 엔티티까지 함께 삭제되는 것을 확인할 수 있을 것이다.

**만약 CascadeType.REMOVE로 설정하지 않고 부모 엔티티만 삭제하려고 한다면 데이터베이스에 부모 자식 테이블에 걸려있는 외래 키 제약조건으로 인해서
데이터베이스에서 외래키 무결성 예외가 발생한다.**

### CASCADE 종류

```java
public enum CascadeType {
    ALL,        // 모두 적용
    PERSIST,    // 영속
    MERGE,      // 병합
    REMOVE,     // 삭제
    REFRESH,    // REFRESH
    DETACH      // DETACH
}
```


## 고아 객체

JPA는 **부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능**을 제공하는데 이것을 **고아 객체(ORPHAN) 제거**라고 한다.
이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제되도록 할 수 있다.

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    private Long id;
    
    @OneToMany(mappedBy = "parent", orphanRemoval = true) 
    private List<Child> children = new ArrayList<Child>(); 
}
```

고아 객체 제거 기능을 활성화하기 위해서 컬렉션에 orphanRemoval = true로 설정한 것을 확인할 수 있다.
이제 컬렉션에서 제거한 엔티티는 자동으로 삭제된다. **고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하기 떄문에
참조하는 곳이 하나일 때만 사용해야 하는 기능이다.**

















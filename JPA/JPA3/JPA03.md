> 자바 ORM 표준 JPA 프로그래밍을 읽고 작성한 내용입니다.
>
# JPA 03

# 플러시(Flush)
> 플러시란 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것이다.
> 

## 플러시가 실행됬을 때
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

## 영속성 컨텍스트를 플러시하는 방법
1. em.flush() 를 직접 호출한다.
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출된다.

JPQL 쿼리 실행 시 자동적으로 플러시가 호출되는 이유는 무엇일까 ?
```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

memberA ~ memberC는 persist() 메서드를 통해서 영속 상태가 되어 있지만 아직 flush를 하지않아서 데이터베이스에는 해당 엔티티들의 내용이 반영되어 있지 않은
상황이다. 이 상황에서 JPQL 쿼리가 실행된다면 어떤 문제가 발생할까? 당연하게도 memberA ~ memberC의 내용이 데이터베이스에 저장되어 있지 않아서 쿼리문의 결과가
예상한 것과는 다르게 나올 수 있다. 그렇기 때문에 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영해야 하므로 JPQL을 실행할 때도 
플러시를 자동 호출한다.

* 참고 : find() 메서드를 호출할 때는 플래시가 실행되지 않는다.

### 플러시 모드 옵션
엔티티 매니저에 플러시 모드를 직접 지정하려면 javax.persistence.FlushModeType을 사용하면 된다.
* FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
* FlushModeType.COMMIT : 커밋할 때만 플러시

플러시는 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안되고 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
하는 것이 플러시다.

## 준영속
> 준영속이란 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 것을 준영속 상태라고 한다.
> 그렇기 때문에 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.
> 

### detach() 메서드로 인해 엔티티가 준영속 상태가 되는 경우
만약 detach() 메서드로 인해 엔티티가 준영속 상태로 되어버린다면 영속성 컨텍스트의 1차 캐시부터 쓰기 지연 SQL 저장소까지 
해당 엔티티를 관리하기 위한 모든 정보가 제거되기 때문에 영속성 컨텍스트는 해당 엔티티를 관리할 수 없게 된다.

### claer() 메서드를 호출한 경우
clear()메서드는 영속성 컨텍스트를 초기화해서 메서드 사용 전 영속성 컨텍스트가 관리하던 엔티티들에 관한 정보가 모두 사라져
모든 엔티티가 준영속 상태가 된다.

### close() 메서드를 호출한 경우
영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.

## 준영속 상태의 특징 
1. 거의 비영속 상태에 가깝다.<br>
   영속성 컨텍스트는 준영속 상태의 엔티티를 관리하지 않기 때문에 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 
   포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다.

2. 식별자 값을 가지고 있다. <br>
   비영속 상태는 식별자 값이 없을수도 있지만 준영속 상태는 영속 상태였던 엔티티이기 때문에 **반드시** 식별자 값을 가지고 있다.

3. 지연 로딩을 할 수 없다.
   지연 로딩(Lazy Loading)은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.
    하지만 준영속 상태는 영속성 컨텍스트가 더는 관리하지 않으므로 지연 로딩 시 문제가 발생한다.

## 엔티티 병합(merge) 
준영속 상태 혹은 비영속 상태의 엔티티를 영속 상태의 엔티티로 변경하려면 병합을 사용하면 된다.
merge() 메서드는 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.

```java
Member mergeMember = em.merge(member);
```
### 병합 메서드가 동작하는 과정
1. 준영속 상태의 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
2. 1차 캐시에 해당 식별자 값을 가지고 있는 엔티티가 없다면 데이터베이스에서 해당 엔티티를 조회하고
   1차 캐시에 저장한다.
3. 조회한 영속 엔티티에 엔티티의 값을 채워 넣는다.
4. 엔티티를 반환한다.

병합은 준영속 엔티티인지 비영속 엔티티인지를 신경쓰지 않는다. 식별자 값을 엔티티를 조회할 수 있으면 병합하고
조회할 수 없다면 새로 엔티티를 생성해서 병합한다. 병합은 Save or Update 기능을 수행한다.






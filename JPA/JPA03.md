> 자바 ORM 표준 JPA 프로그래밍을 읽고 작성한 내용입니다.
>
# JPA 03

# 플러시(Flush)
> 플러시란 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것이다.
> 

## 플러시가 실행됬을 때
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

## 영속성 컨텍스트를 플러시하는 방법
1. em.flush() 를 직접 호출한다.
2. 트랜잭션 커밋 시 플러시가 자동 호출된다.
3. JPQL 쿼리 실행 시 플러시가 자동 호출된다.

JPQL 쿼리 실행 시 자동적으로 플러시가 호출되는 이유는 무엇일까 ?
```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

memberA ~ memberC는 persist() 메서드를 통해서 영속 상태가 되어 있지만 아직 flush를 하지않아서 데이터베이스에는 해당 엔티티들의 내용이 반영되어 있지 않은
상황이다. 이 상황에서 JPQL 쿼리가 실행된다면 어떤 문제가 발생할까? 당연하게도 memberA ~ memberC의 내용이 데이터베이스에 저장되어 있지 않아서 쿼리문의 결과가
예상한 것과는 다르게 나올 수 있다. 그렇기 때문에 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영해야 하므로 JPQL을 실행할 때도 
플러시를 자동 호출한다.

* 참고 : find() 메서드를 호출할 때는 플래시가 실행되지 않는다.

### 플러시 모드 옵션
엔티티 매니저에 플러시 모드를 직접 지정하려면 javax.persistence.FlushModeType을 사용하면 된다.
* FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
* FlushModeType.COMMIT : 커밋할 때만 플러시

플러시는 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안되고 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
하는 것이 플러시다.

## 준영속
> 준영속이란 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 것을 준영속 상태라고 한다.
> 그렇기 때문에 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.